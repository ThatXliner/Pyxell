
import argparse
import os
import json
import platform
import subprocess
import sys
from pathlib import Path
from timeit import default_timer as timer

from .compiler import PyxellCompiler
from .errors import PyxellError
from .indentation import transform_indented_code
from .parsing import parse_program
from .version import __version__

abspath = Path(__file__).parents[1]


units = {}
for name in ['std', 'math', 'random']:
    try:
        unit = json.load(open(abspath/f'lib/{name}.json'))
    except FileNotFoundError:
        unit = None
    units[name] = unit


def build_ast(path):
    code = transform_indented_code(path.read_text())
    return parse_program(code)


def build_libs():
    for name in units:
        path = abspath/f'lib/{name}.px'
        units[name] = build_ast(path)
        json.dump(units[name], open(str(path).replace('.px', '.json'), 'w'), indent='\t')


def cpp_flags(cpp_compiler, opt_level):
    flags = [f'-O{opt_level}', '-std=c++17']
    if 'clang' in cpp_compiler:
        flags.append('-fcoroutines-ts')
    return flags


def precompile_base_header(cpp_compiler, opt_level):
    if cpp_compiler.lower() in {'', 'no', 'none'}:
        return

    command = [cpp_compiler, '-c', str(abspath/'lib/base.hpp'), *cpp_flags(cpp_compiler, opt_level)]
    subprocess.check_output(command, stderr=subprocess.STDOUT)


def run_cpp_compiler(cpp_compiler, cpp_filename, exe_filename, opt_level, verbose=False, disable_warnings=False):
    command = [cpp_compiler, cpp_filename, '-include', str(abspath/'lib/base.hpp'), '-o', exe_filename, *cpp_flags(cpp_compiler, opt_level), '-lstdc++']
    if disable_warnings:
        command.append('-w')
    if platform.system() != 'Windows':
        command.append('-lm')

    if verbose:
        print(f"running {' '.join(command)}")

    try:
        if verbose:
            subprocess.call(command, stderr=subprocess.STDOUT)
        else:
            subprocess.check_output(command, stderr=subprocess.STDOUT)
    except FileNotFoundError:
        print(f"command not found: {cpp_compiler}")


def compile(filepath, cpp_compiler, opt_level, verbose=False):
    filepath = Path(filepath)
    filename, ext = os.path.splitext(filepath)
    cpp_filename = f'{filename}.cpp'
    exe_filename = f'{filename}.exe'

    if verbose:
        print(f"transpiling {filepath} to {cpp_filename}")

    t1 = timer()
    compiler = PyxellCompiler()

    for name, ast in units.items():
        compiler.run(ast, name)

    ast = build_ast(filepath)
    code = compiler.run_main(ast)

    with open(cpp_filename, 'w') as file:
        file.write(f"/* Generated by Pyxell {__version__}. */\n")
        file.write(code)

    t2 = timer()
    global transpilation_time
    transpilation_time = t2 - t1

    if cpp_compiler.lower() in {'', 'no', 'none'}:
        return

    t1 = timer()
    run_cpp_compiler(cpp_compiler, cpp_filename, exe_filename, opt_level, verbose)
    t2 = timer()
    global compilation_time
    compilation_time = t2 - t1

    return exe_filename


def main():
    parser = argparse.ArgumentParser(prog='pyxell', description="Run Pyxell compiler.")
    parser.add_argument('filepath', nargs=argparse.OPTIONAL, help="source file path")
    parser.add_argument('-c', '--cpp-compiler', default='clang', help="C++ compiler command (default: clang)")
    parser.add_argument('-l', '--libs', action='store_true', help="build libraries and exit")
    parser.add_argument('-n', '--dont-run', action='store_true', help="don't run the program after compilation")
    parser.add_argument('-O', '--opt-level', default='2', help="compiler optimization level (default: 2)")
    parser.add_argument('-t', '--time', action='store_true', help="measure time of program compilation and execution")
    parser.add_argument('-v', '--verbose', action='store_true', help="output diagnostic information")
    parser.add_argument('-V', '--version', action='store_true', help="print version number and exit")
    args = parser.parse_args()

    if args.version:
        print(f"Pyxell {__version__}")
        sys.exit(0)

    if args.libs:
        build_libs()
        sys.exit(0)

    if not args.filepath:
        parser.error("filepath is required")

    try:
        exe_filename = compile(args.filepath, args.cpp_compiler, args.opt_level, args.verbose)
    except FileNotFoundError:
        print(f"file not found: {args.filepath}")
        sys.exit(1)
    except PyxellError as e:
        print(str(e))
        sys.exit(1)

    if exe_filename and not args.dont_run:
        if args.verbose:
            print(f"executing {exe_filename}")

        t1 = timer()
        subprocess.call(exe_filename)
        t2 = timer()
        execution_time = t2 - t1

    if args.time:
        print("---")
        print(f"transpilation: {transpilation_time:.3f}s")
        if exe_filename:
            print(f"compilation: {compilation_time:.3f}s")
            if not args.dont_run:
                print(f"execution: {execution_time:.3f}s")
