module SkelPyxell where

-- Haskell module generated by the BNF converter

import AbsPyxell
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x
transProgram :: Show a => Program a -> Result
transProgram x = case x of
  Program _ stmts -> failure x
transBlock :: Show a => Block a -> Result
transBlock x = case x of
  SBlock _ stmts -> failure x
transStmt :: Show a => Stmt a -> Result
transStmt x = case x of
  SSkip _ -> failure x
  SPrint _ expr -> failure x
  SAssg _ exprs -> failure x
  SAssgMul _ expr1 expr2 -> failure x
  SAssgDiv _ expr1 expr2 -> failure x
  SAssgMod _ expr1 expr2 -> failure x
  SAssgAdd _ expr1 expr2 -> failure x
  SAssgSub _ expr1 expr2 -> failure x
  SIf _ branchs else_ -> failure x
  SWhile _ expr block -> failure x
transBranch :: Show a => Branch a -> Result
transBranch x = case x of
  BElIf _ expr block -> failure x
transElse :: Show a => Else a -> Result
transElse x = case x of
  EElse _ block -> failure x
  EEmpty _ -> failure x
transCmp :: Show a => Cmp a -> Result
transCmp x = case x of
  Cmp1 _ expr1 cmpop expr2 -> failure x
  Cmp2 _ expr cmpop cmp -> failure x
transCmpOp :: Show a => CmpOp a -> Result
transCmpOp x = case x of
  CmpEQ _ -> failure x
  CmpNE _ -> failure x
  CmpLT _ -> failure x
  CmpLE _ -> failure x
  CmpGT _ -> failure x
  CmpGE _ -> failure x
transExpr :: Show a => Expr a -> Result
transExpr x = case x of
  EInt _ integer -> failure x
  ETrue _ -> failure x
  EFalse _ -> failure x
  EChar _ char -> failure x
  EString _ string -> failure x
  EArray _ exprs -> failure x
  EVar _ ident -> failure x
  EIndex _ expr1 expr2 -> failure x
  EElem _ expr integer -> failure x
  EMul _ expr1 expr2 -> failure x
  EDiv _ expr1 expr2 -> failure x
  EMod _ expr1 expr2 -> failure x
  EAdd _ expr1 expr2 -> failure x
  ESub _ expr1 expr2 -> failure x
  ENeg _ expr -> failure x
  ECmp _ cmp -> failure x
  ENot _ expr -> failure x
  EAnd _ expr1 expr2 -> failure x
  EOr _ expr1 expr2 -> failure x
  ETuple _ exprs -> failure x
transType :: Show a => Type a -> Result
transType x = case x of
  TDeref _ type_ -> failure x
  TVoid _ -> failure x
  TInt _ -> failure x
  TBool _ -> failure x
  TChar _ -> failure x
  TObject _ -> failure x
  TString _ -> failure x
  TArray _ type_ -> failure x
  TTuple _ types -> failure x

