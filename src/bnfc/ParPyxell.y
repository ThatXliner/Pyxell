-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParPyxell where
import AbsPyxell
import LexPyxell
import ErrM

}

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%name pProgram_internal Program
%name pListStmt_internal ListStmt
%name pStmt_internal Stmt
%name pUse_internal Use
%name pCMemb_internal CMemb
%name pListCMemb_internal ListCMemb
%name pFVars_internal FVars
%name pFVar_internal FVar
%name pListFVar_internal ListFVar
%name pFArg_internal FArg
%name pListFArg_internal ListFArg
%name pFRet_internal FRet
%name pFBody_internal FBody
%name pBlock_internal Block
%name pListExpr_internal ListExpr
%name pBranch_internal Branch
%name pListBranch_internal ListBranch
%name pElse_internal Else
%name pExpr13_internal Expr13
%name pACpr_internal ACpr
%name pListACpr_internal ListACpr
%name pSlice_internal Slice
%name pListSlice_internal ListSlice
%name pCArg_internal CArg
%name pListCArg_internal ListCArg
%name pExpr12_internal Expr12
%name pExpr11_internal Expr11
%name pExpr10_internal Expr10
%name pExpr9_internal Expr9
%name pExpr8_internal Expr8
%name pExpr7_internal Expr7
%name pExpr6_internal Expr6
%name pExpr5_internal Expr5
%name pCmp_internal Cmp
%name pCmpOp_internal CmpOp
%name pExpr4_internal Expr4
%name pExpr3_internal Expr3
%name pExpr1_internal Expr1
%name pListExpr3_internal ListExpr3
%name pListExpr2_internal ListExpr2
%name pExpr2_internal Expr2
%name pListIdent_internal ListIdent
%name pExpr_internal Expr
%name pType4_internal Type4
%name pType3_internal Type3
%name pType2_internal Type2
%name pType1_internal Type1
%name pListType3_internal ListType3
%name pListType2_internal ListType2
%name pType_internal Type
%token
  '!=' { PT _ (TS _ 1) }
  '$' { PT _ (TS _ 2) }
  '$=' { PT _ (TS _ 3) }
  '%' { PT _ (TS _ 4) }
  '%=' { PT _ (TS _ 5) }
  '&' { PT _ (TS _ 6) }
  '&=' { PT _ (TS _ 7) }
  '(' { PT _ (TS _ 8) }
  ')' { PT _ (TS _ 9) }
  '*' { PT _ (TS _ 10) }
  '*=' { PT _ (TS _ 11) }
  '+' { PT _ (TS _ 12) }
  '+=' { PT _ (TS _ 13) }
  ',' { PT _ (TS _ 14) }
  '-' { PT _ (TS _ 15) }
  '-=' { PT _ (TS _ 16) }
  '->' { PT _ (TS _ 17) }
  '.' { PT _ (TS _ 18) }
  '..' { PT _ (TS _ 19) }
  '...' { PT _ (TS _ 20) }
  '/' { PT _ (TS _ 21) }
  '/=' { PT _ (TS _ 22) }
  ':' { PT _ (TS _ 23) }
  ';' { PT _ (TS _ 24) }
  '<' { PT _ (TS _ 25) }
  '<<' { PT _ (TS _ 26) }
  '<<=' { PT _ (TS _ 27) }
  '<=' { PT _ (TS _ 28) }
  '=' { PT _ (TS _ 29) }
  '==' { PT _ (TS _ 30) }
  '>' { PT _ (TS _ 31) }
  '>=' { PT _ (TS _ 32) }
  '>>' { PT _ (TS _ 33) }
  '>>=' { PT _ (TS _ 34) }
  '?' { PT _ (TS _ 35) }
  'Any' { PT _ (TS _ 36) }
  'Bool' { PT _ (TS _ 37) }
  'Char' { PT _ (TS _ 38) }
  'Float' { PT _ (TS _ 39) }
  'Int' { PT _ (TS _ 40) }
  'Num' { PT _ (TS _ 41) }
  'String' { PT _ (TS _ 42) }
  'Void' { PT _ (TS _ 43) }
  '[' { PT _ (TS _ 44) }
  ']' { PT _ (TS _ 45) }
  '^' { PT _ (TS _ 46) }
  '^=' { PT _ (TS _ 47) }
  '_' { PT _ (TS _ 48) }
  'and' { PT _ (TS _ 49) }
  'as' { PT _ (TS _ 50) }
  'break' { PT _ (TS _ 51) }
  'class' { PT _ (TS _ 52) }
  'continue' { PT _ (TS _ 53) }
  'def' { PT _ (TS _ 54) }
  'do' { PT _ (TS _ 55) }
  'elif' { PT _ (TS _ 56) }
  'else' { PT _ (TS _ 57) }
  'extern' { PT _ (TS _ 58) }
  'false' { PT _ (TS _ 59) }
  'for' { PT _ (TS _ 60) }
  'func' { PT _ (TS _ 61) }
  'hiding' { PT _ (TS _ 62) }
  'if' { PT _ (TS _ 63) }
  'in' { PT _ (TS _ 64) }
  'lambda' { PT _ (TS _ 65) }
  'not' { PT _ (TS _ 66) }
  'only' { PT _ (TS _ 67) }
  'or' { PT _ (TS _ 68) }
  'print' { PT _ (TS _ 69) }
  'return' { PT _ (TS _ 70) }
  'skip' { PT _ (TS _ 71) }
  'step' { PT _ (TS _ 72) }
  'true' { PT _ (TS _ 73) }
  'until' { PT _ (TS _ 74) }
  'use' { PT _ (TS _ 75) }
  'while' { PT _ (TS _ 76) }
  '{' { PT _ (TS _ 77) }
  '|' { PT _ (TS _ 78) }
  '|=' { PT _ (TS _ 79) }
  '}' { PT _ (TS _ 80) }
  '~' { PT _ (TS _ 81) }

  L_ident {PT _ (TV _)}
  L_integ {PT _ (TI _)}
  L_doubl {PT _ (TD _)}
  L_charac {PT _ (TC _)}
  L_quoted {PT _ (TL _)}

%%

Ident :: {
  (Maybe (Int, Int), Ident)
}
: L_ident {
  (Just (tokenLineCol $1), Ident (prToken $1)) 
}

Integer :: {
  (Maybe (Int, Int), Integer)
}
: L_integ {
  (Just (tokenLineCol $1), read (prToken $1)) 
}

Double :: {
  (Maybe (Int, Int), Double)
}
: L_doubl {
  (Just (tokenLineCol $1), read (prToken $1)) 
}

Char :: {
  (Maybe (Int, Int), Char)
}
: L_charac {
  (Just (tokenLineCol $1), read (prToken $1)) 
}

String :: {
  (Maybe (Int, Int), String)
}
: L_quoted {
  (Just (tokenLineCol $1), prToken $1)
}

Program :: {
  (Maybe (Int, Int), Program (Maybe (Int, Int)))
}
: ListStmt {
  (fst $1, AbsPyxell.Program (fst $1)(snd $1)) 
}

ListStmt :: {
  (Maybe (Int, Int), [Stmt (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| Stmt {
  (fst $1, (:[]) (snd $1)) 
}
| Stmt ';' ListStmt {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Stmt :: {
  (Maybe (Int, Int), Stmt (Maybe (Int, Int)))
}
: 'use' Ident Use {
  (Just (tokenLineCol $1), AbsPyxell.SUse (Just (tokenLineCol $1)) (snd $2)(snd $3)) 
}
| 'class' Ident 'def' '{' ListCMemb '}' {
  (Just (tokenLineCol $1), AbsPyxell.SClass (Just (tokenLineCol $1)) (snd $2)(snd $5)) 
}
| 'func' Ident FVars '(' ListFArg ')' FRet FBody {
  (Just (tokenLineCol $1), AbsPyxell.SFunc (Just (tokenLineCol $1)) (snd $2)(snd $3)(snd $5)(snd $7)(snd $8)) 
}
| 'return' {
  (Just (tokenLineCol $1), AbsPyxell.SRetVoid (Just (tokenLineCol $1)))
}
| 'return' Expr {
  (Just (tokenLineCol $1), AbsPyxell.SRetExpr (Just (tokenLineCol $1)) (snd $2)) 
}
| 'skip' {
  (Just (tokenLineCol $1), AbsPyxell.SSkip (Just (tokenLineCol $1)))
}
| 'print' Expr {
  (Just (tokenLineCol $1), AbsPyxell.SPrint (Just (tokenLineCol $1)) (snd $2)) 
}
| 'print' {
  (Just (tokenLineCol $1), AbsPyxell.SPrintEmpty (Just (tokenLineCol $1)))
}
| ListExpr {
  (fst $1, AbsPyxell.SAssg (fst $1)(snd $1)) 
}
| Expr '^=' Expr {
  (fst $1, AbsPyxell.SAssgPow (fst $1)(snd $1)(snd $3)) 
}
| Expr '*=' Expr {
  (fst $1, AbsPyxell.SAssgMul (fst $1)(snd $1)(snd $3)) 
}
| Expr '/=' Expr {
  (fst $1, AbsPyxell.SAssgDiv (fst $1)(snd $1)(snd $3)) 
}
| Expr '%=' Expr {
  (fst $1, AbsPyxell.SAssgMod (fst $1)(snd $1)(snd $3)) 
}
| Expr '+=' Expr {
  (fst $1, AbsPyxell.SAssgAdd (fst $1)(snd $1)(snd $3)) 
}
| Expr '-=' Expr {
  (fst $1, AbsPyxell.SAssgSub (fst $1)(snd $1)(snd $3)) 
}
| Expr '<<=' Expr {
  (fst $1, AbsPyxell.SAssgBShl (fst $1)(snd $1)(snd $3)) 
}
| Expr '>>=' Expr {
  (fst $1, AbsPyxell.SAssgBShr (fst $1)(snd $1)(snd $3)) 
}
| Expr '&=' Expr {
  (fst $1, AbsPyxell.SAssgBAnd (fst $1)(snd $1)(snd $3)) 
}
| Expr '|=' Expr {
  (fst $1, AbsPyxell.SAssgBOr (fst $1)(snd $1)(snd $3)) 
}
| Expr '$=' Expr {
  (fst $1, AbsPyxell.SAssgBXor (fst $1)(snd $1)(snd $3)) 
}
| 'if' ListBranch Else {
  (Just (tokenLineCol $1), AbsPyxell.SIf (Just (tokenLineCol $1)) (snd $2)(snd $3)) 
}
| 'while' Expr 'do' Block {
  (Just (tokenLineCol $1), AbsPyxell.SWhile (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}
| 'until' Expr 'do' Block {
  (Just (tokenLineCol $1), AbsPyxell.SUntil (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}
| 'for' Expr 'in' Expr 'do' Block {
  (Just (tokenLineCol $1), AbsPyxell.SFor (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $6)) 
}
| 'for' Expr 'in' Expr 'step' Expr 'do' Block {
  (Just (tokenLineCol $1), AbsPyxell.SForStep (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $6)(snd $8)) 
}
| 'continue' {
  (Just (tokenLineCol $1), AbsPyxell.SContinue (Just (tokenLineCol $1)))
}
| 'break' {
  (Just (tokenLineCol $1), AbsPyxell.SBreak (Just (tokenLineCol $1)))
}

Use :: {
  (Maybe (Int, Int), Use (Maybe (Int, Int)))
}
: {
  (Nothing, AbsPyxell.UAll Nothing)
}
| 'only' ListIdent {
  (Just (tokenLineCol $1), AbsPyxell.UOnly (Just (tokenLineCol $1)) (snd $2)) 
}
| 'hiding' ListIdent {
  (Just (tokenLineCol $1), AbsPyxell.UHiding (Just (tokenLineCol $1)) (snd $2)) 
}
| 'as' Ident {
  (Just (tokenLineCol $1), AbsPyxell.UAs (Just (tokenLineCol $1)) (snd $2)) 
}

CMemb :: {
  (Maybe (Int, Int), CMemb (Maybe (Int, Int)))
}
: Type Ident {
  (fst $1, AbsPyxell.MField (fst $1)(snd $1)(snd $2)) 
}
| Type Ident ':' Expr {
  (fst $1, AbsPyxell.MFieldDefault (fst $1)(snd $1)(snd $2)(snd $4)) 
}

ListCMemb :: {
  (Maybe (Int, Int), [CMemb (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| CMemb {
  (fst $1, (:[]) (snd $1)) 
}
| CMemb ';' ListCMemb {
  (fst $1, (:) (snd $1)(snd $3)) 
}

FVars :: {
  (Maybe (Int, Int), FVars (Maybe (Int, Int)))
}
: {
  (Nothing, AbsPyxell.FStd Nothing)
}
| '<' ListFVar '>' {
  (Just (tokenLineCol $1), AbsPyxell.FGen (Just (tokenLineCol $1)) (snd $2)) 
}

FVar :: {
  (Maybe (Int, Int), FVar (Maybe (Int, Int)))
}
: Type Ident {
  (fst $1, AbsPyxell.FVar (fst $1)(snd $1)(snd $2)) 
}

ListFVar :: {
  (Maybe (Int, Int), [FVar (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| FVar {
  (fst $1, (:[]) (snd $1)) 
}
| FVar ',' ListFVar {
  (fst $1, (:) (snd $1)(snd $3)) 
}

FArg :: {
  (Maybe (Int, Int), FArg (Maybe (Int, Int)))
}
: Type Ident {
  (fst $1, AbsPyxell.ANoDefault (fst $1)(snd $1)(snd $2)) 
}
| Type Ident ':' Expr2 {
  (fst $1, AbsPyxell.ADefault (fst $1)(snd $1)(snd $2)(snd $4)) 
}

ListFArg :: {
  (Maybe (Int, Int), [FArg (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| FArg {
  (fst $1, (:[]) (snd $1)) 
}
| FArg ',' ListFArg {
  (fst $1, (:) (snd $1)(snd $3)) 
}

FRet :: {
  (Maybe (Int, Int), FRet (Maybe (Int, Int)))
}
: {
  (Nothing, AbsPyxell.FProc Nothing)
}
| Type {
  (fst $1, AbsPyxell.FFunc (fst $1)(snd $1)) 
}

FBody :: {
  (Maybe (Int, Int), FBody (Maybe (Int, Int)))
}
: 'def' Block {
  (Just (tokenLineCol $1), AbsPyxell.FDef (Just (tokenLineCol $1)) (snd $2)) 
}
| 'extern' {
  (Just (tokenLineCol $1), AbsPyxell.FExtern (Just (tokenLineCol $1)))
}

Block :: {
  (Maybe (Int, Int), Block (Maybe (Int, Int)))
}
: '{' ListStmt '}' {
  (Just (tokenLineCol $1), AbsPyxell.SBlock (Just (tokenLineCol $1)) (snd $2)) 
}

ListExpr :: {
  (Maybe (Int, Int), [Expr (Maybe (Int, Int))]) 
}
: Expr {
  (fst $1, (:[]) (snd $1)) 
}
| Expr '=' ListExpr {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Branch :: {
  (Maybe (Int, Int), Branch (Maybe (Int, Int)))
}
: Expr 'do' Block {
  (fst $1, AbsPyxell.BElIf (fst $1)(snd $1)(snd $3)) 
}

ListBranch :: {
  (Maybe (Int, Int), [Branch (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| Branch {
  (fst $1, (:[]) (snd $1)) 
}
| Branch 'elif' ListBranch {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Else :: {
  (Maybe (Int, Int), Else (Maybe (Int, Int)))
}
: 'else' 'do' Block {
  (Just (tokenLineCol $1), AbsPyxell.EElse (Just (tokenLineCol $1)) (snd $3)) 
}
| {
  (Nothing, AbsPyxell.EEmpty Nothing)
}

Expr13 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: '_' {
  (Just (tokenLineCol $1), AbsPyxell.EStub (Just (tokenLineCol $1)))
}
| Integer {
  (fst $1, AbsPyxell.EInt (fst $1)(snd $1)) 
}
| Double {
  (fst $1, AbsPyxell.EFloat (fst $1)(snd $1)) 
}
| 'true' {
  (Just (tokenLineCol $1), AbsPyxell.ETrue (Just (tokenLineCol $1)))
}
| 'false' {
  (Just (tokenLineCol $1), AbsPyxell.EFalse (Just (tokenLineCol $1)))
}
| Char {
  (fst $1, AbsPyxell.EChar (fst $1)(snd $1)) 
}
| String {
  (fst $1, AbsPyxell.EString (fst $1)(snd $1)) 
}
| '[' ListExpr2 ']' {
  (Just (tokenLineCol $1), AbsPyxell.EArray (Just (tokenLineCol $1)) (snd $2)) 
}
| '[' Expr2 ListACpr ']' {
  (Just (tokenLineCol $1), AbsPyxell.EArrayCpr (Just (tokenLineCol $1)) (snd $2)(snd $3)) 
}
| Ident {
  (fst $1, AbsPyxell.EVar (fst $1)(snd $1)) 
}
| Expr13 '[' Expr ']' {
  (fst $1, AbsPyxell.EIndex (fst $1)(snd $1)(snd $3)) 
}
| Expr13 '[' ListSlice ']' {
  (fst $1, AbsPyxell.ESlice (fst $1)(snd $1)(snd $3)) 
}
| Expr13 '.' Ident {
  (fst $1, AbsPyxell.EAttr (fst $1)(snd $1)(snd $3)) 
}
| Expr13 '(' ListCArg ')' {
  (fst $1, AbsPyxell.ECall (fst $1)(snd $1)(snd $3)) 
}
| '(' Expr ')' {
  (Just (tokenLineCol $1), snd $2)
}

ACpr :: {
  (Maybe (Int, Int), ACpr (Maybe (Int, Int)))
}
: 'for' Expr 'in' Expr {
  (Just (tokenLineCol $1), AbsPyxell.CprFor (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}
| 'for' Expr 'in' Expr 'step' Expr {
  (Just (tokenLineCol $1), AbsPyxell.CprForStep (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $6)) 
}
| 'if' Expr {
  (Just (tokenLineCol $1), AbsPyxell.CprIf (Just (tokenLineCol $1)) (snd $2)) 
}

ListACpr :: {
  (Maybe (Int, Int), [ACpr (Maybe (Int, Int))]) 
}
: ACpr {
  (fst $1, (:[]) (snd $1)) 
}
| ACpr ListACpr {
  (fst $1, (:) (snd $1)(snd $2)) 
}

Slice :: {
  (Maybe (Int, Int), Slice (Maybe (Int, Int)))
}
: Expr {
  (fst $1, AbsPyxell.SliceExpr (fst $1)(snd $1)) 
}
| {
  (Nothing, AbsPyxell.SliceNone Nothing)
}

ListSlice :: {
  (Maybe (Int, Int), [Slice (Maybe (Int, Int))]) 
}
: Slice {
  (fst $1, (:[]) (snd $1)) 
}
| Slice ':' ListSlice {
  (fst $1, (:) (snd $1)(snd $3)) 
}

CArg :: {
  (Maybe (Int, Int), CArg (Maybe (Int, Int)))
}
: Expr2 {
  (fst $1, AbsPyxell.APos (fst $1)(snd $1)) 
}
| Ident '=' Expr2 {
  (fst $1, AbsPyxell.ANamed (fst $1)(snd $1)(snd $3)) 
}

ListCArg :: {
  (Maybe (Int, Int), [CArg (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| CArg {
  (fst $1, (:[]) (snd $1)) 
}
| CArg ',' ListCArg {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Expr12 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr13 '^' Expr12 {
  (fst $1, AbsPyxell.EPow (fst $1)(snd $1)(snd $3)) 
}
| '-' Expr12 {
  (Just (tokenLineCol $1), AbsPyxell.EMinus (Just (tokenLineCol $1)) (snd $2)) 
}
| '+' Expr12 {
  (Just (tokenLineCol $1), AbsPyxell.EPlus (Just (tokenLineCol $1)) (snd $2)) 
}
| '~' Expr12 {
  (Just (tokenLineCol $1), AbsPyxell.EBNot (Just (tokenLineCol $1)) (snd $2)) 
}
| Expr13 {
  (fst $1, snd $1)
}

Expr11 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr11 '*' Expr12 {
  (fst $1, AbsPyxell.EMul (fst $1)(snd $1)(snd $3)) 
}
| Expr11 '/' Expr12 {
  (fst $1, AbsPyxell.EDiv (fst $1)(snd $1)(snd $3)) 
}
| Expr11 '%' Expr12 {
  (fst $1, AbsPyxell.EMod (fst $1)(snd $1)(snd $3)) 
}
| Expr12 {
  (fst $1, snd $1)
}

Expr10 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr10 '+' Expr11 {
  (fst $1, AbsPyxell.EAdd (fst $1)(snd $1)(snd $3)) 
}
| Expr10 '-' Expr11 {
  (fst $1, AbsPyxell.ESub (fst $1)(snd $1)(snd $3)) 
}
| Expr11 {
  (fst $1, snd $1)
}

Expr9 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr9 '<<' Expr10 {
  (fst $1, AbsPyxell.EBShl (fst $1)(snd $1)(snd $3)) 
}
| Expr9 '>>' Expr10 {
  (fst $1, AbsPyxell.EBShr (fst $1)(snd $1)(snd $3)) 
}
| Expr10 {
  (fst $1, snd $1)
}

Expr8 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr8 '&' Expr9 {
  (fst $1, AbsPyxell.EBAnd (fst $1)(snd $1)(snd $3)) 
}
| Expr9 {
  (fst $1, snd $1)
}

Expr7 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr7 '|' Expr8 {
  (fst $1, AbsPyxell.EBOr (fst $1)(snd $1)(snd $3)) 
}
| Expr7 '$' Expr8 {
  (fst $1, AbsPyxell.EBXor (fst $1)(snd $1)(snd $3)) 
}
| Expr8 {
  (fst $1, snd $1)
}

Expr6 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr7 '..' Expr7 {
  (fst $1, AbsPyxell.ERangeIncl (fst $1)(snd $1)(snd $3)) 
}
| Expr7 '...' Expr7 {
  (fst $1, AbsPyxell.ERangeExcl (fst $1)(snd $1)(snd $3)) 
}
| Expr7 '...' {
  (fst $1, AbsPyxell.ERangeInf (fst $1)(snd $1)) 
}
| Expr7 {
  (fst $1, snd $1)
}

Expr5 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Cmp {
  (fst $1, AbsPyxell.ECmp (fst $1)(snd $1)) 
}
| 'not' Expr5 {
  (Just (tokenLineCol $1), AbsPyxell.ENot (Just (tokenLineCol $1)) (snd $2)) 
}
| Expr6 {
  (fst $1, snd $1)
}

Cmp :: {
  (Maybe (Int, Int), Cmp (Maybe (Int, Int)))
}
: Expr6 CmpOp Expr6 {
  (fst $1, AbsPyxell.Cmp1 (fst $1)(snd $1)(snd $2)(snd $3)) 
}
| Expr6 CmpOp Cmp {
  (fst $1, AbsPyxell.Cmp2 (fst $1)(snd $1)(snd $2)(snd $3)) 
}

CmpOp :: {
  (Maybe (Int, Int), CmpOp (Maybe (Int, Int)))
}
: '==' {
  (Just (tokenLineCol $1), AbsPyxell.CmpEQ (Just (tokenLineCol $1)))
}
| '!=' {
  (Just (tokenLineCol $1), AbsPyxell.CmpNE (Just (tokenLineCol $1)))
}
| '<' {
  (Just (tokenLineCol $1), AbsPyxell.CmpLT (Just (tokenLineCol $1)))
}
| '<=' {
  (Just (tokenLineCol $1), AbsPyxell.CmpLE (Just (tokenLineCol $1)))
}
| '>' {
  (Just (tokenLineCol $1), AbsPyxell.CmpGT (Just (tokenLineCol $1)))
}
| '>=' {
  (Just (tokenLineCol $1), AbsPyxell.CmpGE (Just (tokenLineCol $1)))
}

Expr4 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr5 'and' Expr4 {
  (fst $1, AbsPyxell.EAnd (fst $1)(snd $1)(snd $3)) 
}
| Expr5 {
  (fst $1, snd $1)
}

Expr3 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr4 'or' Expr3 {
  (fst $1, AbsPyxell.EOr (fst $1)(snd $1)(snd $3)) 
}
| Expr4 {
  (fst $1, snd $1)
}

Expr1 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: ListExpr3 {
  (fst $1, AbsPyxell.ETuple (fst $1)(snd $1)) 
}
| Expr2 {
  (fst $1, snd $1)
}

ListExpr3 :: {
  (Maybe (Int, Int), [Expr (Maybe (Int, Int))]) 
}
: Expr3 {
  (fst $1, (:[]) (snd $1)) 
}
| Expr3 ',' ListExpr3 {
  (fst $1, (:) (snd $1)(snd $3)) 
}

ListExpr2 :: {
  (Maybe (Int, Int), [Expr (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| Expr2 {
  (fst $1, (:[]) (snd $1)) 
}
| Expr2 ',' ListExpr2 {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Expr2 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr3 '?' Expr3 ':' Expr2 {
  (fst $1, AbsPyxell.ECond (fst $1)(snd $1)(snd $3)(snd $5)) 
}
| 'lambda' ListIdent '->' Expr2 {
  (Just (tokenLineCol $1), AbsPyxell.ELambda (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}
| Expr3 {
  (fst $1, snd $1)
}

ListIdent :: {
  (Maybe (Int, Int), [Ident]) 
}
: {
  (Nothing, [])
}
| Ident {
  (fst $1, (:[]) (snd $1)) 
}
| Ident ',' ListIdent {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Expr :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr1 {
  (fst $1, snd $1)
}

Type4 :: {
  (Maybe (Int, Int), Type (Maybe (Int, Int)))
}
: Ident {
  (fst $1, AbsPyxell.TVar (fst $1)(snd $1)) 
}
| 'Void' {
  (Just (tokenLineCol $1), AbsPyxell.TVoid (Just (tokenLineCol $1)))
}
| 'Int' {
  (Just (tokenLineCol $1), AbsPyxell.TInt (Just (tokenLineCol $1)))
}
| 'Float' {
  (Just (tokenLineCol $1), AbsPyxell.TFloat (Just (tokenLineCol $1)))
}
| 'Bool' {
  (Just (tokenLineCol $1), AbsPyxell.TBool (Just (tokenLineCol $1)))
}
| 'Char' {
  (Just (tokenLineCol $1), AbsPyxell.TChar (Just (tokenLineCol $1)))
}
| 'String' {
  (Just (tokenLineCol $1), AbsPyxell.TString (Just (tokenLineCol $1)))
}
| '(' Type ')' {
  (Just (tokenLineCol $1), snd $2)
}

Type3 :: {
  (Maybe (Int, Int), Type (Maybe (Int, Int)))
}
: '[' Type ']' {
  (Just (tokenLineCol $1), AbsPyxell.TArray (Just (tokenLineCol $1)) (snd $2)) 
}
| Type4 {
  (fst $1, snd $1)
}

Type2 :: {
  (Maybe (Int, Int), Type (Maybe (Int, Int)))
}
: ListType3 {
  (fst $1, AbsPyxell.TTuple (fst $1)(snd $1)) 
}
| Type3 {
  (fst $1, snd $1)
}

Type1 :: {
  (Maybe (Int, Int), Type (Maybe (Int, Int)))
}
: ListType2 '->' Type1 {
  (fst $1, AbsPyxell.TFunc (fst $1)(snd $1)(snd $3)) 
}
| 'Any' {
  (Just (tokenLineCol $1), AbsPyxell.TAny (Just (tokenLineCol $1)))
}
| 'Num' {
  (Just (tokenLineCol $1), AbsPyxell.TNum (Just (tokenLineCol $1)))
}
| Type2 {
  (fst $1, snd $1)
}

ListType3 :: {
  (Maybe (Int, Int), [Type (Maybe (Int, Int))]) 
}
: Type3 {
  (fst $1, (:[]) (snd $1)) 
}
| Type3 '*' ListType3 {
  (fst $1, (:) (snd $1)(snd $3)) 
}

ListType2 :: {
  (Maybe (Int, Int), [Type (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| Type2 {
  (fst $1, (:[]) (snd $1)) 
}
| Type2 ',' ListType2 {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Type :: {
  (Maybe (Int, Int), Type (Maybe (Int, Int)))
}
: Type1 {
  (fst $1, snd $1)
}

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens

pProgram = (>>= return . snd) . pProgram_internal
pListStmt = (>>= return . snd) . pListStmt_internal
pStmt = (>>= return . snd) . pStmt_internal
pUse = (>>= return . snd) . pUse_internal
pCMemb = (>>= return . snd) . pCMemb_internal
pListCMemb = (>>= return . snd) . pListCMemb_internal
pFVars = (>>= return . snd) . pFVars_internal
pFVar = (>>= return . snd) . pFVar_internal
pListFVar = (>>= return . snd) . pListFVar_internal
pFArg = (>>= return . snd) . pFArg_internal
pListFArg = (>>= return . snd) . pListFArg_internal
pFRet = (>>= return . snd) . pFRet_internal
pFBody = (>>= return . snd) . pFBody_internal
pBlock = (>>= return . snd) . pBlock_internal
pListExpr = (>>= return . snd) . pListExpr_internal
pBranch = (>>= return . snd) . pBranch_internal
pListBranch = (>>= return . snd) . pListBranch_internal
pElse = (>>= return . snd) . pElse_internal
pExpr13 = (>>= return . snd) . pExpr13_internal
pACpr = (>>= return . snd) . pACpr_internal
pListACpr = (>>= return . snd) . pListACpr_internal
pSlice = (>>= return . snd) . pSlice_internal
pListSlice = (>>= return . snd) . pListSlice_internal
pCArg = (>>= return . snd) . pCArg_internal
pListCArg = (>>= return . snd) . pListCArg_internal
pExpr12 = (>>= return . snd) . pExpr12_internal
pExpr11 = (>>= return . snd) . pExpr11_internal
pExpr10 = (>>= return . snd) . pExpr10_internal
pExpr9 = (>>= return . snd) . pExpr9_internal
pExpr8 = (>>= return . snd) . pExpr8_internal
pExpr7 = (>>= return . snd) . pExpr7_internal
pExpr6 = (>>= return . snd) . pExpr6_internal
pExpr5 = (>>= return . snd) . pExpr5_internal
pCmp = (>>= return . snd) . pCmp_internal
pCmpOp = (>>= return . snd) . pCmpOp_internal
pExpr4 = (>>= return . snd) . pExpr4_internal
pExpr3 = (>>= return . snd) . pExpr3_internal
pExpr1 = (>>= return . snd) . pExpr1_internal
pListExpr3 = (>>= return . snd) . pListExpr3_internal
pListExpr2 = (>>= return . snd) . pListExpr2_internal
pExpr2 = (>>= return . snd) . pExpr2_internal
pListIdent = (>>= return . snd) . pListIdent_internal
pExpr = (>>= return . snd) . pExpr_internal
pType4 = (>>= return . snd) . pType4_internal
pType3 = (>>= return . snd) . pType3_internal
pType2 = (>>= return . snd) . pType2_internal
pType1 = (>>= return . snd) . pType1_internal
pListType3 = (>>= return . snd) . pListType3_internal
pListType2 = (>>= return . snd) . pListType2_internal
pType = (>>= return . snd) . pType_internal
}

