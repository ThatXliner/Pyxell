

module AbsPyxell where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program a = Program a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Program a stmts -> Program (f a) (map (fmap f) stmts)
data Block a = SBlock a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Block where
    fmap f x = case x of
        SBlock a stmts -> SBlock (f a) (map (fmap f) stmts)
data Stmt a
    = SSkip a
    | SPrint a (Expr a)
    | SAssg a [Expr a]
    | SAssgMul a (Expr a) (Expr a)
    | SAssgDiv a (Expr a) (Expr a)
    | SAssgMod a (Expr a) (Expr a)
    | SAssgAdd a (Expr a) (Expr a)
    | SAssgSub a (Expr a) (Expr a)
    | SIf a [Branch a] (Else a)
    | SWhile a (Expr a) (Block a)
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        SSkip a -> SSkip (f a)
        SPrint a expr -> SPrint (f a) (fmap f expr)
        SAssg a exprs -> SAssg (f a) (map (fmap f) exprs)
        SAssgMul a expr1 expr2 -> SAssgMul (f a) (fmap f expr1) (fmap f expr2)
        SAssgDiv a expr1 expr2 -> SAssgDiv (f a) (fmap f expr1) (fmap f expr2)
        SAssgMod a expr1 expr2 -> SAssgMod (f a) (fmap f expr1) (fmap f expr2)
        SAssgAdd a expr1 expr2 -> SAssgAdd (f a) (fmap f expr1) (fmap f expr2)
        SAssgSub a expr1 expr2 -> SAssgSub (f a) (fmap f expr1) (fmap f expr2)
        SIf a branchs else_ -> SIf (f a) (map (fmap f) branchs) (fmap f else_)
        SWhile a expr block -> SWhile (f a) (fmap f expr) (fmap f block)
data Branch a = BElIf a (Expr a) (Block a)
  deriving (Eq, Ord, Show, Read)

instance Functor Branch where
    fmap f x = case x of
        BElIf a expr block -> BElIf (f a) (fmap f expr) (fmap f block)
data Else a = EElse a (Block a) | EEmpty a
  deriving (Eq, Ord, Show, Read)

instance Functor Else where
    fmap f x = case x of
        EElse a block -> EElse (f a) (fmap f block)
        EEmpty a -> EEmpty (f a)
data Cmp a
    = Cmp1 a (Expr a) (CmpOp a) (Expr a)
    | Cmp2 a (Expr a) (CmpOp a) (Cmp a)
  deriving (Eq, Ord, Show, Read)

instance Functor Cmp where
    fmap f x = case x of
        Cmp1 a expr1 cmpop expr2 -> Cmp1 (f a) (fmap f expr1) (fmap f cmpop) (fmap f expr2)
        Cmp2 a expr cmpop cmp -> Cmp2 (f a) (fmap f expr) (fmap f cmpop) (fmap f cmp)
data CmpOp a
    = CmpEQ a | CmpNE a | CmpLT a | CmpLE a | CmpGT a | CmpGE a
  deriving (Eq, Ord, Show, Read)

instance Functor CmpOp where
    fmap f x = case x of
        CmpEQ a -> CmpEQ (f a)
        CmpNE a -> CmpNE (f a)
        CmpLT a -> CmpLT (f a)
        CmpLE a -> CmpLE (f a)
        CmpGT a -> CmpGT (f a)
        CmpGE a -> CmpGE (f a)
data Expr a
    = EInt a Integer
    | ETrue a
    | EFalse a
    | EString a String
    | EVar a Ident
    | EElem a (Expr a) Integer
    | EMul a (Expr a) (Expr a)
    | EDiv a (Expr a) (Expr a)
    | EMod a (Expr a) (Expr a)
    | EAdd a (Expr a) (Expr a)
    | ESub a (Expr a) (Expr a)
    | ENeg a (Expr a)
    | ECmp a (Cmp a)
    | ENot a (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
    | ETuple a [Expr a]
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EInt a integer -> EInt (f a) integer
        ETrue a -> ETrue (f a)
        EFalse a -> EFalse (f a)
        EString a string -> EString (f a) string
        EVar a ident -> EVar (f a) ident
        EElem a expr integer -> EElem (f a) (fmap f expr) integer
        EMul a expr1 expr2 -> EMul (f a) (fmap f expr1) (fmap f expr2)
        EDiv a expr1 expr2 -> EDiv (f a) (fmap f expr1) (fmap f expr2)
        EMod a expr1 expr2 -> EMod (f a) (fmap f expr1) (fmap f expr2)
        EAdd a expr1 expr2 -> EAdd (f a) (fmap f expr1) (fmap f expr2)
        ESub a expr1 expr2 -> ESub (f a) (fmap f expr1) (fmap f expr2)
        ENeg a expr -> ENeg (f a) (fmap f expr)
        ECmp a cmp -> ECmp (f a) (fmap f cmp)
        ENot a expr -> ENot (f a) (fmap f expr)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)
        ETuple a exprs -> ETuple (f a) (map (fmap f) exprs)
data Type a
    = TDeref a (Type a)
    | TVoid a
    | TInt a
    | TBool a
    | TString a
    | TTuple a [Type a]
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        TDeref a type_ -> TDeref (f a) (fmap f type_)
        TVoid a -> TVoid (f a)
        TInt a -> TInt (f a)
        TBool a -> TBool (f a)
        TString a -> TString (f a)
        TTuple a types -> TTuple (f a) (map (fmap f) types)
