

module AbsPyxell where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program a = Program a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Program a stmts -> Program (f a) (map (fmap f) stmts)
data Stmt a
    = SUse a Ident (Use a)
    | SClass a Ident (CExt a) [CMemb a]
    | SFunc a Ident (FVars a) [FArg a] (FRet a) (FBody a)
    | SRetVoid a
    | SRetExpr a (Expr a)
    | SSkip a
    | SPrint a (Expr a)
    | SPrintEmpty a
    | SAssg a [Expr a]
    | SAssgPow a (Expr a) (Expr a)
    | SAssgMul a (Expr a) (Expr a)
    | SAssgDiv a (Expr a) (Expr a)
    | SAssgMod a (Expr a) (Expr a)
    | SAssgAdd a (Expr a) (Expr a)
    | SAssgSub a (Expr a) (Expr a)
    | SAssgBShl a (Expr a) (Expr a)
    | SAssgBShr a (Expr a) (Expr a)
    | SAssgBAnd a (Expr a) (Expr a)
    | SAssgBOr a (Expr a) (Expr a)
    | SAssgBXor a (Expr a) (Expr a)
    | SIf a [Branch a] (Else a)
    | SWhile a (Expr a) (Block a)
    | SUntil a (Expr a) (Block a)
    | SFor a (Expr a) (Expr a) (Block a)
    | SForStep a (Expr a) (Expr a) (Expr a) (Block a)
    | SContinue a
    | SBreak a
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        SUse a ident use -> SUse (f a) ident (fmap f use)
        SClass a ident cext cmembs -> SClass (f a) ident (fmap f cext) (map (fmap f) cmembs)
        SFunc a ident fvars fargs fret fbody -> SFunc (f a) ident (fmap f fvars) (map (fmap f) fargs) (fmap f fret) (fmap f fbody)
        SRetVoid a -> SRetVoid (f a)
        SRetExpr a expr -> SRetExpr (f a) (fmap f expr)
        SSkip a -> SSkip (f a)
        SPrint a expr -> SPrint (f a) (fmap f expr)
        SPrintEmpty a -> SPrintEmpty (f a)
        SAssg a exprs -> SAssg (f a) (map (fmap f) exprs)
        SAssgPow a expr1 expr2 -> SAssgPow (f a) (fmap f expr1) (fmap f expr2)
        SAssgMul a expr1 expr2 -> SAssgMul (f a) (fmap f expr1) (fmap f expr2)
        SAssgDiv a expr1 expr2 -> SAssgDiv (f a) (fmap f expr1) (fmap f expr2)
        SAssgMod a expr1 expr2 -> SAssgMod (f a) (fmap f expr1) (fmap f expr2)
        SAssgAdd a expr1 expr2 -> SAssgAdd (f a) (fmap f expr1) (fmap f expr2)
        SAssgSub a expr1 expr2 -> SAssgSub (f a) (fmap f expr1) (fmap f expr2)
        SAssgBShl a expr1 expr2 -> SAssgBShl (f a) (fmap f expr1) (fmap f expr2)
        SAssgBShr a expr1 expr2 -> SAssgBShr (f a) (fmap f expr1) (fmap f expr2)
        SAssgBAnd a expr1 expr2 -> SAssgBAnd (f a) (fmap f expr1) (fmap f expr2)
        SAssgBOr a expr1 expr2 -> SAssgBOr (f a) (fmap f expr1) (fmap f expr2)
        SAssgBXor a expr1 expr2 -> SAssgBXor (f a) (fmap f expr1) (fmap f expr2)
        SIf a branchs else_ -> SIf (f a) (map (fmap f) branchs) (fmap f else_)
        SWhile a expr block -> SWhile (f a) (fmap f expr) (fmap f block)
        SUntil a expr block -> SUntil (f a) (fmap f expr) (fmap f block)
        SFor a expr1 expr2 block -> SFor (f a) (fmap f expr1) (fmap f expr2) (fmap f block)
        SForStep a expr1 expr2 expr3 block -> SForStep (f a) (fmap f expr1) (fmap f expr2) (fmap f expr3) (fmap f block)
        SContinue a -> SContinue (f a)
        SBreak a -> SBreak (f a)
data Use a
    = UAll a | UOnly a [Ident] | UHiding a [Ident] | UAs a Ident
  deriving (Eq, Ord, Show, Read)

instance Functor Use where
    fmap f x = case x of
        UAll a -> UAll (f a)
        UOnly a idents -> UOnly (f a) idents
        UHiding a idents -> UHiding (f a) idents
        UAs a ident -> UAs (f a) ident
data CExt a = CNoExt a | CExt a (Type a)
  deriving (Eq, Ord, Show, Read)

instance Functor CExt where
    fmap f x = case x of
        CNoExt a -> CNoExt (f a)
        CExt a type_ -> CExt (f a) (fmap f type_)
data CMemb a
    = MField a (Type a) Ident
    | MFieldDefault a (Type a) Ident (Expr a)
    | MMethodCode a Ident [FArg a] (FRet a) (MBody a)
    | MConstructor a [FArg a] (Block a)
    | MMethod a Ident (Type a)
  deriving (Eq, Ord, Show, Read)

instance Functor CMemb where
    fmap f x = case x of
        MField a type_ ident -> MField (f a) (fmap f type_) ident
        MFieldDefault a type_ ident expr -> MFieldDefault (f a) (fmap f type_) ident (fmap f expr)
        MMethodCode a ident fargs fret mbody -> MMethodCode (f a) ident (map (fmap f) fargs) (fmap f fret) (fmap f mbody)
        MConstructor a fargs block -> MConstructor (f a) (map (fmap f) fargs) (fmap f block)
        MMethod a ident type_ -> MMethod (f a) ident (fmap f type_)
data MBody a = MDef a (Block a) | MAbstract a
  deriving (Eq, Ord, Show, Read)

instance Functor MBody where
    fmap f x = case x of
        MDef a block -> MDef (f a) (fmap f block)
        MAbstract a -> MAbstract (f a)
data FVars a = FStd a | FGen a [FVar a]
  deriving (Eq, Ord, Show, Read)

instance Functor FVars where
    fmap f x = case x of
        FStd a -> FStd (f a)
        FGen a fvars -> FGen (f a) (map (fmap f) fvars)
data FVar a = FVar a (Type a) Ident
  deriving (Eq, Ord, Show, Read)

instance Functor FVar where
    fmap f x = case x of
        FVar a type_ ident -> FVar (f a) (fmap f type_) ident
data FArg a
    = ANoDefault a (Type a) Ident | ADefault a (Type a) Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor FArg where
    fmap f x = case x of
        ANoDefault a type_ ident -> ANoDefault (f a) (fmap f type_) ident
        ADefault a type_ ident expr -> ADefault (f a) (fmap f type_) ident (fmap f expr)
data FRet a = FProc a | FFunc a (Type a)
  deriving (Eq, Ord, Show, Read)

instance Functor FRet where
    fmap f x = case x of
        FProc a -> FProc (f a)
        FFunc a type_ -> FFunc (f a) (fmap f type_)
data FBody a = FDef a (Block a) | FExtern a
  deriving (Eq, Ord, Show, Read)

instance Functor FBody where
    fmap f x = case x of
        FDef a block -> FDef (f a) (fmap f block)
        FExtern a -> FExtern (f a)
data Block a = SBlock a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Block where
    fmap f x = case x of
        SBlock a stmts -> SBlock (f a) (map (fmap f) stmts)
data Branch a = BElIf a (Expr a) (Block a)
  deriving (Eq, Ord, Show, Read)

instance Functor Branch where
    fmap f x = case x of
        BElIf a expr block -> BElIf (f a) (fmap f expr) (fmap f block)
data Else a = EElse a (Block a) | EEmpty a
  deriving (Eq, Ord, Show, Read)

instance Functor Else where
    fmap f x = case x of
        EElse a block -> EElse (f a) (fmap f block)
        EEmpty a -> EEmpty (f a)
data ACpr a
    = CprFor a (Expr a) (Expr a)
    | CprForStep a (Expr a) (Expr a) (Expr a)
    | CprIf a (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor ACpr where
    fmap f x = case x of
        CprFor a expr1 expr2 -> CprFor (f a) (fmap f expr1) (fmap f expr2)
        CprForStep a expr1 expr2 expr3 -> CprForStep (f a) (fmap f expr1) (fmap f expr2) (fmap f expr3)
        CprIf a expr -> CprIf (f a) (fmap f expr)
data Slice a = SliceExpr a (Expr a) | SliceNone a
  deriving (Eq, Ord, Show, Read)

instance Functor Slice where
    fmap f x = case x of
        SliceExpr a expr -> SliceExpr (f a) (fmap f expr)
        SliceNone a -> SliceNone (f a)
data CArg a = APos a (Expr a) | ANamed a Ident (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor CArg where
    fmap f x = case x of
        APos a expr -> APos (f a) (fmap f expr)
        ANamed a ident expr -> ANamed (f a) ident (fmap f expr)
data Cmp a
    = Cmp1 a (Expr a) (CmpOp a) (Expr a)
    | Cmp2 a (Expr a) (CmpOp a) (Cmp a)
  deriving (Eq, Ord, Show, Read)

instance Functor Cmp where
    fmap f x = case x of
        Cmp1 a expr1 cmpop expr2 -> Cmp1 (f a) (fmap f expr1) (fmap f cmpop) (fmap f expr2)
        Cmp2 a expr cmpop cmp -> Cmp2 (f a) (fmap f expr) (fmap f cmpop) (fmap f cmp)
data CmpOp a
    = CmpEQ a | CmpNE a | CmpLT a | CmpLE a | CmpGT a | CmpGE a
  deriving (Eq, Ord, Show, Read)

instance Functor CmpOp where
    fmap f x = case x of
        CmpEQ a -> CmpEQ (f a)
        CmpNE a -> CmpNE (f a)
        CmpLT a -> CmpLT (f a)
        CmpLE a -> CmpLE (f a)
        CmpGT a -> CmpGT (f a)
        CmpGE a -> CmpGE (f a)
data Expr a
    = EStub a
    | EInt a Integer
    | EFloat a Double
    | ETrue a
    | EFalse a
    | EChar a Char
    | EString a String
    | EArray a [Expr a]
    | EArrayCpr a (Expr a) [ACpr a]
    | EVar a Ident
    | EIndex a (Expr a) (Expr a)
    | ESlice a (Expr a) [Slice a]
    | EAttr a (Expr a) Ident
    | ECall a (Expr a) [CArg a]
    | EPow a (Expr a) (Expr a)
    | EMinus a (Expr a)
    | EPlus a (Expr a)
    | EBNot a (Expr a)
    | EMul a (Expr a) (Expr a)
    | EDiv a (Expr a) (Expr a)
    | EMod a (Expr a) (Expr a)
    | EAdd a (Expr a) (Expr a)
    | ESub a (Expr a) (Expr a)
    | EBShl a (Expr a) (Expr a)
    | EBShr a (Expr a) (Expr a)
    | EBAnd a (Expr a) (Expr a)
    | EBOr a (Expr a) (Expr a)
    | EBXor a (Expr a) (Expr a)
    | ERangeIncl a (Expr a) (Expr a)
    | ERangeExcl a (Expr a) (Expr a)
    | ERangeInf a (Expr a)
    | ECmp a (Cmp a)
    | ENot a (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
    | ETuple a [Expr a]
    | ECond a (Expr a) (Expr a) (Expr a)
    | ELambda a [Ident] (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EStub a -> EStub (f a)
        EInt a integer -> EInt (f a) integer
        EFloat a double -> EFloat (f a) double
        ETrue a -> ETrue (f a)
        EFalse a -> EFalse (f a)
        EChar a char -> EChar (f a) char
        EString a string -> EString (f a) string
        EArray a exprs -> EArray (f a) (map (fmap f) exprs)
        EArrayCpr a expr acprs -> EArrayCpr (f a) (fmap f expr) (map (fmap f) acprs)
        EVar a ident -> EVar (f a) ident
        EIndex a expr1 expr2 -> EIndex (f a) (fmap f expr1) (fmap f expr2)
        ESlice a expr slices -> ESlice (f a) (fmap f expr) (map (fmap f) slices)
        EAttr a expr ident -> EAttr (f a) (fmap f expr) ident
        ECall a expr cargs -> ECall (f a) (fmap f expr) (map (fmap f) cargs)
        EPow a expr1 expr2 -> EPow (f a) (fmap f expr1) (fmap f expr2)
        EMinus a expr -> EMinus (f a) (fmap f expr)
        EPlus a expr -> EPlus (f a) (fmap f expr)
        EBNot a expr -> EBNot (f a) (fmap f expr)
        EMul a expr1 expr2 -> EMul (f a) (fmap f expr1) (fmap f expr2)
        EDiv a expr1 expr2 -> EDiv (f a) (fmap f expr1) (fmap f expr2)
        EMod a expr1 expr2 -> EMod (f a) (fmap f expr1) (fmap f expr2)
        EAdd a expr1 expr2 -> EAdd (f a) (fmap f expr1) (fmap f expr2)
        ESub a expr1 expr2 -> ESub (f a) (fmap f expr1) (fmap f expr2)
        EBShl a expr1 expr2 -> EBShl (f a) (fmap f expr1) (fmap f expr2)
        EBShr a expr1 expr2 -> EBShr (f a) (fmap f expr1) (fmap f expr2)
        EBAnd a expr1 expr2 -> EBAnd (f a) (fmap f expr1) (fmap f expr2)
        EBOr a expr1 expr2 -> EBOr (f a) (fmap f expr1) (fmap f expr2)
        EBXor a expr1 expr2 -> EBXor (f a) (fmap f expr1) (fmap f expr2)
        ERangeIncl a expr1 expr2 -> ERangeIncl (f a) (fmap f expr1) (fmap f expr2)
        ERangeExcl a expr1 expr2 -> ERangeExcl (f a) (fmap f expr1) (fmap f expr2)
        ERangeInf a expr -> ERangeInf (f a) (fmap f expr)
        ECmp a cmp -> ECmp (f a) (fmap f cmp)
        ENot a expr -> ENot (f a) (fmap f expr)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)
        ETuple a exprs -> ETuple (f a) (map (fmap f) exprs)
        ECond a expr1 expr2 expr3 -> ECond (f a) (fmap f expr1) (fmap f expr2) (fmap f expr3)
        ELambda a idents expr -> ELambda (f a) idents (fmap f expr)
data Type a
    = TPtr a (Type a)
    | TArr a Integer (Type a)
    | TDeref a (Type a)
    | TVar a Ident
    | TVoid a
    | TInt a
    | TFloat a
    | TBool a
    | TChar a
    | TString a
    | TArray a (Type a)
    | TTuple a [Type a]
    | TFunc a [Type a] (Type a)
    | TFuncDef a Ident [FVar a] [FArg a] (Type a) (Block a)
    | TFuncAbstract a Ident [FVar a] [FArg a] (Type a)
    | TFuncExt a Ident [FArg a] (Type a)
    | TClass a Ident [Type a] [CMemb a]
    | TModule a
    | TAny a
    | TNum a
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        TPtr a type_ -> TPtr (f a) (fmap f type_)
        TArr a integer type_ -> TArr (f a) integer (fmap f type_)
        TDeref a type_ -> TDeref (f a) (fmap f type_)
        TVar a ident -> TVar (f a) ident
        TVoid a -> TVoid (f a)
        TInt a -> TInt (f a)
        TFloat a -> TFloat (f a)
        TBool a -> TBool (f a)
        TChar a -> TChar (f a)
        TString a -> TString (f a)
        TArray a type_ -> TArray (f a) (fmap f type_)
        TTuple a types -> TTuple (f a) (map (fmap f) types)
        TFunc a types type_ -> TFunc (f a) (map (fmap f) types) (fmap f type_)
        TFuncDef a ident fvars fargs type_ block -> TFuncDef (f a) ident (map (fmap f) fvars) (map (fmap f) fargs) (fmap f type_) (fmap f block)
        TFuncAbstract a ident fvars fargs type_ -> TFuncAbstract (f a) ident (map (fmap f) fvars) (map (fmap f) fargs) (fmap f type_)
        TFuncExt a ident fargs type_ -> TFuncExt (f a) ident (map (fmap f) fargs) (fmap f type_)
        TClass a ident types cmembs -> TClass (f a) ident (map (fmap f) types) (map (fmap f) cmembs)
        TModule a -> TModule (f a)
        TAny a -> TAny (f a)
        TNum a -> TNum (f a)
