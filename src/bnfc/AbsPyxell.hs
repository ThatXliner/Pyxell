

module AbsPyxell where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data Program a = Program a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Program where
    fmap f x = case x of
        Program a stmts -> Program (f a) (map (fmap f) stmts)
data Stmt a
    = SSkip a
    | SAssg a Ident (Expr a)
    | SIf a [Branch a] (Else a)
    | SWhile a (Expr a) (Block a)
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        SSkip a -> SSkip (f a)
        SAssg a ident expr -> SAssg (f a) ident (fmap f expr)
        SIf a branchs else_ -> SIf (f a) (map (fmap f) branchs) (fmap f else_)
        SWhile a expr block -> SWhile (f a) (fmap f expr) (fmap f block)
data Block a = SBlock a [Stmt a]
  deriving (Eq, Ord, Show, Read)

instance Functor Block where
    fmap f x = case x of
        SBlock a stmts -> SBlock (f a) (map (fmap f) stmts)
data Branch a = BElIf a (Expr a) (Block a)
  deriving (Eq, Ord, Show, Read)

instance Functor Branch where
    fmap f x = case x of
        BElIf a expr block -> BElIf (f a) (fmap f expr) (fmap f block)
data Else a = EElse a (Block a) | EEmpty a
  deriving (Eq, Ord, Show, Read)

instance Functor Else where
    fmap f x = case x of
        EElse a block -> EElse (f a) (fmap f block)
        EEmpty a -> EEmpty (f a)
data CmpOp a
    = CmpEQ a | CmpNE a | CmpLT a | CmpLE a | CmpGT a | CmpGE a
  deriving (Eq, Ord, Show, Read)

instance Functor CmpOp where
    fmap f x = case x of
        CmpEQ a -> CmpEQ (f a)
        CmpNE a -> CmpNE (f a)
        CmpLT a -> CmpLT (f a)
        CmpLE a -> CmpLE (f a)
        CmpGT a -> CmpGT (f a)
        CmpGE a -> CmpGE (f a)
data Expr a
    = EInt a Integer
    | ETrue a
    | EFalse a
    | EStr a String
    | EVar a Ident
    | EMul a (Expr a) (Expr a)
    | EDiv a (Expr a) (Expr a)
    | EMod a (Expr a) (Expr a)
    | EAdd a (Expr a) (Expr a)
    | ESub a (Expr a) (Expr a)
    | ENeg a (Expr a)
    | ECmp a (Expr a) (CmpOp a) (Expr a)
    | ENot a (Expr a)
    | EAnd a (Expr a) (Expr a)
    | EOr a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EInt a integer -> EInt (f a) integer
        ETrue a -> ETrue (f a)
        EFalse a -> EFalse (f a)
        EStr a string -> EStr (f a) string
        EVar a ident -> EVar (f a) ident
        EMul a expr1 expr2 -> EMul (f a) (fmap f expr1) (fmap f expr2)
        EDiv a expr1 expr2 -> EDiv (f a) (fmap f expr1) (fmap f expr2)
        EMod a expr1 expr2 -> EMod (f a) (fmap f expr1) (fmap f expr2)
        EAdd a expr1 expr2 -> EAdd (f a) (fmap f expr1) (fmap f expr2)
        ESub a expr1 expr2 -> ESub (f a) (fmap f expr1) (fmap f expr2)
        ENeg a expr -> ENeg (f a) (fmap f expr)
        ECmp a expr1 cmpop expr2 -> ECmp (f a) (fmap f expr1) (fmap f cmpop) (fmap f expr2)
        ENot a expr -> ENot (f a) (fmap f expr)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)
data Type a = TInt a | TBool a
  deriving (Eq, Ord, Show, Read)

instance Functor Type where
    fmap f x = case x of
        TInt a -> TInt (f a)
        TBool a -> TBool (f a)
